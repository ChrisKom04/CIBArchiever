
+---------+----------------------+-----------------------------+
|         | Data- |              | Free- |          |          |
| Header  | Free- | Data-Blocks  | List  |  MYZList | MYZNodes |                        
|         | List  |              |       |          |          |
+---------+----------------------+-----------------------------+
                  Data                      MetaData

Αξίζει να αναφέρουμε πως το αρχείο γίνεται mapped στη κύρια μνήμη οπότε οφελούμαστε από το γεγονός ότι ορισμένες σελίδες παραμένουν στην κύρια μνήμη, ενώ επίσης
μπορεί το διάβασμα γειτονικών λογικών blocks να απαιτεί λιγότερα διαβάσματα από τον δίσκο.

-Οργάνωση Μεταδεδομένων:

    >Σχεδιάστηκε με βάση την προτεινόμενη οργάνωση.

    >Χωρίζουμε το τμήμα των μεταδεδομένων σε blocks των 1024 bytes.

    >Το πρώτο block του τμήματος των μεταδεδομένων κρατά πληροφορίες που αφορούν τα ελεύθερα
     μπλοκς του τμήματος των μεταδεδομένων.

    >Ακολουθούν τα blocks του πίνακα MYZ-Node-List τα οποία βρίσκονται σε συνεχόμενες θέσεις μνήμης. Τα entries
     του πίνακα που αφορούν αρχεία/δεσμούς "δείχνουν" σε data-blocks ενώ αυτά που αφορούν σε καταλόγους "δείχνουν" σε
     MYZNodes.

    >Στο τέλος, βρίσκονται τα blocks που αφορούν σε MYZNodes. Ένα MYZNode περιλαμβάνει ζευγάρια <entry_id, name> και χρησιμοποιείται
     από καταλόγους ώστε να αποτυπώνεται η λογική ιεραρχία. Φυσικά ένα MYZNode μπορεί να εκτείνεται σε πολλαπλά blocks. Για τον λόγο
     αυτό τα blocks που αφορούν ένα MYZNode σχηματίζουν μία συνδεδεμένη λίστα.

    >Η αρίθμηση των blocks που αφορούν σε MYZNodes γίνεται σε σχέση με το τέλος της MYZList. Αυτό σημαίνει ότι αύξηση του μεγέθοθυς της
     MYZList δεν επηρεάζει τους δείκτες προς MYZNodes. Αντίστοιχα το ίδιο ισχύει και για τα blocks της λίστας. Προσδιορίζονται ως προς το τέλος
     του τμήματος δεδομένων.

    Αναζήτηση Ελέυθερων blocks για να χρησιμοποιηθούν ως MYZNodes:
        
        ~Στο πρώτο block του τμήματος μεταδεδομένων, το οποίο ονομάζουμε freelist υπάρχει ένας κυκλικός buffer που χωράει ένα πεπερασμένο
         πλήθος BlocksIds. Όποτε ελευθερώνεται κάποιο block προστίθεται στον buffer. Όταν ο buffer γεμίσει τότε τα ελεύθερα blocks εκτός buffer 
         θα σχηματίσουν μία συνδεδεμένη λίστα.

    Αναζήτηση Ελεύθερων Κελιών του πίνακα για την εισαγωγή Entries:

        ~Κάθε block του πίνακα έχει ένα 32-bit bitmap που καταγράφει εάν η i-οστή θέση στον πίνακα είναι κενή ή όχι.

        ~Επιπλέον, θεωρούμε πως τα blocks του πίνακα ανήκουν σε 64-άδες, 64^2-άδες, 64^3-άδες, .., κλπ με βάση τη θέση τους. Για παράδειγμα, το block
         0 είναι το block 0 της 64-άδας 0, της 64^2-άδας 0, ..., κλπ ενώ το block 64^2 + 1 είναι το block 1 της 64-άδας 0, της 64^2-άδας 1, της 64^3-άδας 0, ...

        ~Κάθε block του πίνακα περιλαμβάνει επιπλέον ένα 64-bit bitmap που προσδιορίζει ποια σετ(64-άδων, 64^2-άδων, κλπ) έχουν κενές θέσεις. Ο τρόπος που
         αποτυπώνεται αυτή η πληροφορία είναι ο εξής:
          
          Το bitmap του block 0 μίας 64-άδας καταγράφει εάν το i-οστό block εντός της 64-άδας έχει ελεύθερη θέση στον πίνακά του.

          Το bitmap του block 1 μίας 64-άδας καταγράφει εάν η i-οστή 64-άδα από blocks περιλαμβάνει κάποιο block με ελέυθερη θέση στον πίνακά του.

          Το bitmap του block 2 μίας 64-άδας καταγράφει εάν η i-οστή 64^2-άδα από blocks περιλαμβάνει κάποιο block με ελέυθερη θέση στον πίνακά του.

          κ.ο.κ.
                                                                                                 +--------------+
        ~Με αυτόν τον τρόπο η εύρεση ελεύθερου block MYZList για την εισαγωγή ενός entry απαιτεί |O(log_{64}(n))| διαβάσματα blocks, όπου n το πλήθος των MYZList blocks. 
                                                                                                 +--------------+
        ~Κατά την διαγραφή εγγραφών ίσως χρειαστεί η ενημέρωση των bitmaps άλλων blocks με αντίστοιχο τρόπο.
                                                                                                 

-Οργάνωση Δεδομένων:

    >Χωρίζουμε το τμήμα των Δεδομένων σε blocks. Blocks που βρίσκονται σε συνεχόμενες θέσεις μνήμης και χρησιμοποιούνται είτε για την αποθήκευση του ίδιου
     αρχείου είτε είναι κενά σχηματίζουν chunks.

    >Το πρώτο byte ενός chunk περιέχει την τιμή 0 εάν είναι κενό ή την τιμή 1 εάν χρησιμοποιείται για την αποθήκευση κάποιου αρχείου/δεσμού.

    >Στα τελευταία 8 bytes ενός chunk καθώς και στο εσωτερικό του πρώτου block του chunk αποθηκεύεται το πλήθος των blocks που καταλαμβάνει.

    >Με αυτόν τον τρόπο γίνεται εύκολη η συνένωση ενός ελεύθερου chunk με τα γειτονικά του.

    >Στο πρώτο block του τμήματος δεδομένων κρατάμε πληροφορίες σχετικά με τα ελεύθερα chunks. Πιο συγκεκριμένα υπάρχει ένας πίνακας πεπερασμένου μεγέθους
    που συγκρατεί τα ελεύθερα chunks καθώς και το μέγεθός τους σε φθίνουσα σειρά με βάση το μέγεθός τους. Εάν ο πίνακας γεμίσει τότε συνεχίζει ως διπλά συνδεδεμένη
    λίστα που αποτελείται από chunks (κάθε ελεύθερο chunk έχει δείκτη προς το προηγούμενο και το επόμενο ελεύθερο).

    >Κατά την εισαγωγή ενός αρχείου/δεσμού επιλέγεται από τα υπάρχονται ελεύθερα chunks που βρίσκονται στον πίνακα με πολιτική best-fit. Στη συνέχεια, από αυτό το
    chunk κρατάμε μόνο όσα blocks χρειαζόμαστε, επιλέγοντας εκείνα που είναι πιο κοντά στην κεφαλίδα, και δημιουργούμε με τα υπόλοιπα ένα νέο, μικρότερο, chunk το
    οποίο εισάγουμε στα ελεύθερα chunks. 
    
    Εφόσον δεν βρεθεί κάποιο αρκετά μεγάλο chunk τότε κάνουμε truncate το αρχείο και μετακινούμε το τμήμα των μεταδεδομένων για να
    δημιουργηθεί ένα νέο, αρκετά μεγάλο chunk. Ωστόσο το σενάριο αυτό είναι εξαιρετικά σπάνιο αφού κάνουμε allocate αρκετό χώρο πριν προχωρήσουμε στην εισαγωγή των αρχείων,

    >Κατά την δημιουργία του .myz ή την προσθήκη αρχείων ενδέχεται δεσμεύονται chunks εξαρχής τα οποία ενδέχεται να είναι περισσότερα από όσα χρειάζονται. Ωστόσο,
    επειδή προτιμώνται τα blocks που βρίσκονται πιο κοντά στην κεφαλίδα τα blocks που περισσεύουν σχηματίζουν ένα chunk στο τέλος του τμήματος δεδομένων. Έτσι, στο τέλος
    της εισαγωγής των αρχείων μετακινούμε το τμήμα των μεταδεδομένων και μειώνουμε το μέγεθος του αρχείου. Η πρακτική αυτή είναι ταχύτερη από την συνεχή αυξομείωση και
    μετακίνηση των περιεχομένων του αρχείου.


-Επιπλέον Βελτιώσεις:

    >Τα myz_nodes περιλαμβάνουν ονόματα στατικού μεγέθους, maximum 256 χαρακτήρες. Αυτό έχει σαν αποτέλεσμα να σπαταλάμε αρκετό χώρο. Η καλύτερη επιλογή, η οποία
    ωστόσο αυξάνει την πολυπλοκότητα, είναι τα ζευγάρια <entry id, όνομα> να καταλαμβάνουν δυναμικό πλήθος χαρακτήρων.

    >Η προσθήκη block της MYZList του τμήματος δεδομένων απαιτεί την μετακίνηση όλων των blocks που αφορούν σε myz_nodes. Μία άλλη, απλή σχετικά, αλλαγή είναι αύξηση του
    τμήματος μεταδεδομένων κατά ένα μπλοκ, μετακίνηση του block 0 των myz_node blocks το τελευταίο, καινούργιο block, και η παραχώρηση του block 0 στο block της λίστας.
    Ωστόσο, αυτό προυποθέτει την αλλαγή της αρίθμησης των blocks στο τμήμα των μεταδεδομένων ενώ επίσης κάθε myz_node block θα πρέπει να γνωρίζει από ποιο myz_node block ή
    myz_entry "δείχνεται" ώστε να μπορεί να αλλάξει τον δεδομένο pointer.

    >Στο τμήμα των δεδομένων δύναται να υπάρξει fragmentation λόγω του τρόπου με τον οποίο παραχωρούνται blocks. Θα πρέπει να αναζητηθεί κάποιο καλύτερο policy επιλογής chunk. 